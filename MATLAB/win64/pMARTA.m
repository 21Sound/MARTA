function [methodinfo,structs,enuminfo,ThunkLibName]=pMARTA
%PMARTA Create structures to define interfaces found in 'MARTA'.

%This function was generated by loadlibrary.m parser version  on Mon Feb 27 11:19:59 2017
%perl options:'MARTA.i -outfile=pMARTA.m -thunkfile=libMARTA_thunk_pcwin64.c -header=MARTA.h'
ival={cell(1,0)}; % change 0 to the actual number of functions to preallocate the data.
structs=[];enuminfo=[];fcnNum=1;
fcns=struct('name',ival,'calltype',ival,'LHS',ival,'RHS',ival,'alias',ival,'thunkname', ival);
MfilePath=fileparts(mfilename('fullpath'));
ThunkLibName=fullfile(MfilePath,'libMARTA_thunk_pcwin64');
% void * initMARTA ( uint16_t iBlockLen , uint16_t iNumBuffers ); 
fcns.thunkname{fcnNum}='voidPtruint16uint16Thunk';fcns.name{fcnNum}='initMARTA'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='voidPtr'; fcns.RHS{fcnNum}={'uint16', 'uint16'};fcnNum=fcnNum+1;
% int inStream ( void * myPtrToMARTA , int16_t iInDeviceNr , uint32_t iFs , uint32_t iNumChans ); 
fcns.thunkname{fcnNum}='int32voidPtrint16uint32uint32Thunk';fcns.name{fcnNum}='inStream'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'int16', 'uint32', 'uint32'};fcnNum=fcnNum+1;
% int outStream ( void * myPtrToMARTA , int16_t iOutDeviceNr , uint32_t iFs , uint32_t iNumChans ); 
fcns.thunkname{fcnNum}='int32voidPtrint16uint32uint32Thunk';fcns.name{fcnNum}='outStream'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'int16', 'uint32', 'uint32'};fcnNum=fcnNum+1;
% int duplex ( void * myPtrToMARTA , int16_t iDuplexDeviceNr , uint32_t iFs , uint32_t iNumChans ); 
fcns.thunkname{fcnNum}='int32voidPtrint16uint32uint32Thunk';fcns.name{fcnNum}='duplex'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'int16', 'uint32', 'uint32'};fcnNum=fcnNum+1;
% int streamToFile ( void * myPtrToMARTA , const char * sFileName , int16_t iInDeviceNr , uint32_t iFs , uint32_t iNumChans , uint32_t iFormat ); 
fcns.thunkname{fcnNum}='int32voidPtrcstringint16uint32uint32uint32Thunk';fcns.name{fcnNum}='streamToFile'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'cstring', 'int16', 'uint32', 'uint32', 'uint32'};fcnNum=fcnNum+1;
% int streamFromFile ( void * myPtrToMARTA , const char * sFileName , int16_t iOutDeviceNr ); 
fcns.thunkname{fcnNum}='int32voidPtrcstringint16Thunk';fcns.name{fcnNum}='streamFromFile'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'cstring', 'int16'};fcnNum=fcnNum+1;
% int seek ( void * myPtrToMARTA , double fNormOffset ); 
fcns.thunkname{fcnNum}='int32voidPtrdoubleThunk';fcns.name{fcnNum}='seek'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'double'};fcnNum=fcnNum+1;
% int setGain ( void * myPtrToMARTA , double fGainLog ); 
fcns.thunkname{fcnNum}='int32voidPtrdoubleThunk';fcns.name{fcnNum}='setGain'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'double'};fcnNum=fcnNum+1;
% int toggleLimiter ( void * myPtrToMARTA ); 
fcns.thunkname{fcnNum}='int32voidPtrThunk';fcns.name{fcnNum}='toggleLimiter'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr'};fcnNum=fcnNum+1;
% int toggleMono ( void * myPtrToMARTA ); 
fcns.thunkname{fcnNum}='int32voidPtrThunk';fcns.name{fcnNum}='toggleMono'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr'};fcnNum=fcnNum+1;
% uint16_t getNumDevices ( void * myPtrToMARTA ); 
fcns.thunkname{fcnNum}='uint16voidPtrThunk';fcns.name{fcnNum}='getNumDevices'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint16'; fcns.RHS{fcnNum}={'voidPtr'};fcnNum=fcnNum+1;
% double getLimitGain ( void * myPtrToMARTA ); 
fcns.thunkname{fcnNum}='doublevoidPtrThunk';fcns.name{fcnNum}='getLimitGain'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='double'; fcns.RHS{fcnNum}={'voidPtr'};fcnNum=fcnNum+1;
% double getNormPosition ( void * myPtrToMARTA ); 
fcns.thunkname{fcnNum}='doublevoidPtrThunk';fcns.name{fcnNum}='getNormPosition'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='double'; fcns.RHS{fcnNum}={'voidPtr'};fcnNum=fcnNum+1;
% int getCurrentDataPos ( void * myPtrToCppRTA ); 
fcns.thunkname{fcnNum}='int32voidPtrThunk';fcns.name{fcnNum}='getCurrentDataPos'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr'};fcnNum=fcnNum+1;
% int getDataBuf ( void * myPtrToCppRTA , double vData [], uint16_t iBufPos ); 
fcns.thunkname{fcnNum}='int32voidPtrvoidPtruint16Thunk';fcns.name{fcnNum}='getDataBuf'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'doublePtr', 'uint16'};fcnNum=fcnNum+1;
% int setDataBuf ( void * myPtrToCppRTA , double vData [], uint16_t iBufPos ); 
fcns.thunkname{fcnNum}='int32voidPtrvoidPtruint16Thunk';fcns.name{fcnNum}='setDataBuf'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'doublePtr', 'uint16'};fcnNum=fcnNum+1;
% unsigned int getStdOutDev ( void * myPtrToMARTA ); 
fcns.thunkname{fcnNum}='uint32voidPtrThunk';fcns.name{fcnNum}='getStdOutDev'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'voidPtr'};fcnNum=fcnNum+1;
% unsigned int getStdDuplexDev ( void * myPtrToMARTA ); 
fcns.thunkname{fcnNum}='uint32voidPtrThunk';fcns.name{fcnNum}='getStdDuplexDev'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'voidPtr'};fcnNum=fcnNum+1;
% uint32_t getSampRate ( void * myPtrToMARTA ); 
fcns.thunkname{fcnNum}='uint32voidPtrThunk';fcns.name{fcnNum}='getSampRate'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'voidPtr'};fcnNum=fcnNum+1;
% uint16_t getNumChans ( void * myPtrToMARTA ); 
fcns.thunkname{fcnNum}='uint16voidPtrThunk';fcns.name{fcnNum}='getNumChans'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint16'; fcns.RHS{fcnNum}={'voidPtr'};fcnNum=fcnNum+1;
% int isInitialized ( void * myPtrToMARTA ); 
fcns.thunkname{fcnNum}='int32voidPtrThunk';fcns.name{fcnNum}='isInitialized'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr'};fcnNum=fcnNum+1;
% const char * getDeviceInfoStr ( void * myPtrToMARTA , uint16_t iDevNr ); 
fcns.thunkname{fcnNum}='cstringvoidPtruint16Thunk';fcns.name{fcnNum}='getDeviceInfoStr'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='cstring'; fcns.RHS{fcnNum}={'voidPtr', 'uint16'};fcnNum=fcnNum+1;
% const char * getActErrMsg ( void * myPtrToMARTA ); 
fcns.thunkname{fcnNum}='cstringvoidPtrThunk';fcns.name{fcnNum}='getActErrMsg'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='cstring'; fcns.RHS{fcnNum}={'voidPtr'};fcnNum=fcnNum+1;
% int releaseMARTA ( void * myPtrToMARTA ); 
fcns.thunkname{fcnNum}='int32voidPtrThunk';fcns.name{fcnNum}='releaseMARTA'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr'};fcnNum=fcnNum+1;
methodinfo=fcns;